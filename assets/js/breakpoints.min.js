var breakpoints = (function () {
  "use strict";

  // Main function, which is the public interface
  function main(config) {
    // Initializes the internal object with the provided configuration
    core.init(config);
  }

  // Internal object containing all the logic
  var core = {
    // List of breakpoints
    list: null,

    // Cached media queries
    media: {},

    // Registered event listeners
    events: [],

    /**
     * Initializes the object.
     * @param {object} config The configuration object.
     */
    init: function (config) {
      core.list = config;
      window.addEventListener("resize", core.poll);
      window.addEventListener("orientationchange", core.poll);
      window.addEventListener("load", core.poll);
      window.addEventListener("fullscreenchange", core.poll);
    },

    /**
     * Checks if a given query is active.
     * @param {string} query The query to check.
     * @return {boolean} True if the query is active, false otherwise.
     */
    active: function (query) {
      var operator, name, a, b, range, units, str;

      // If the query is not already in our media cache, parse it
      if (!(query in core.media)) {
        // Default operator is 'eq' (equals)
        operator = "eq";
        name = query;

        // Parse operator and name from the query string
        if (query.substr(0, 2) == ">=") {
          operator = "gte";
          name = query.substr(2);
        } else if (query.substr(0, 2) == "<=") {
          operator = "lte";
          name = query.substr(2);
        } else if (query.substr(0, 1) == ">") {
          operator = "gt";
          name = query.substr(1);
        } else if (query.substr(0, 1) == "<") {
          operator = "lt";
          name = query.substr(1);
        } else if (query.substr(0, 1) == "!") {
          operator = "not";
          name = query.substr(1);
        }

        // Check if the breakpoint name exists in our list
        if (name && name in core.list) {
          range = core.list[name];

          // Handle array-based ranges [min, max]
          if (Array.isArray(range)) {
            a = parseInt(range[0]);
            b = parseInt(range[1]);

            // Get units if they exist (e.g., 'px', 'em')
            if (isNaN(a)) {
              if (isNaN(b)) {
                return;
              }
              units = range[1].substr(String(b).length);
            } else {
              units = range[0].substr(String(a).length);
            }

            // Build media query string based on the operator and range
            if (isNaN(a)) {
              // No min value
              switch (operator) {
                case "gte":
                  str = "screen";
                  break;
                case "lte":
                  str = "screen and (max-width: " + b + units + ")";
                  break;
                case "gt":
                  str = "screen and (min-width: " + (b + 1) + units + ")";
                  break;
                case "lt":
                  str = "screen and (max-width: -1px)";
                  break;
                case "not":
                  str = "screen and (min-width: " + (b + 1) + units + ")";
                  break;
                default:
                  str = "screen and (max-width: " + b + units + ")";
                  break;
              }
            } else if (isNaN(b)) {
              // No max value
              switch (operator) {
                case "gte":
                  str = "screen and (min-width: " + a + units + ")";
                  break;
                case "lte":
                  str = "screen";
                  break;
                case "gt":
                  str = "screen and (max-width: -1px)";
                  break;
                case "lt":
                  str = "screen and (max-width: " + (a - 1) + units + ")";
                  break;
                case "not":
                  str = "screen and (max-width: " + (a - 1) + units + ")";
                  break;
                default:
                  str = "screen and (min-width: " + a + units + ")";
                  break;
              }
            } else {
              // Both min and max values exist
              switch (operator) {
                case "gte":
                  str = "screen and (min-width: " + a + units + ")";
                  break;
                case "lte":
                  str = "screen and (max-width: " + b + units + ")";
                  break;
                case "gt":
                  str = "screen and (min-width: " + (b + 1) + units + ")";
                  break;
                case "lt":
                  str = "screen and (max-width: " + (a - 1) + units + ")";
                  break;
                case "not":
                  str =
                    "screen and (max-width: " +
                    (a - 1) +
                    units +
                    "), screen and (min-width: " +
                    (b + 1) +
                    units +
                    ")";
                  break;
                default:
                  str =
                    "screen and (min-width: " +
                    a +
                    units +
                    ") and (max-width: " +
                    b +
                    units +
                    ")";
                  break;
              }
            }
          } else {
            // Handle string-based ranges
            str = range.charAt(0) == "(" ? "screen and " + range : range;
          }

          // Cache the generated media query string
          core.media[query] = !!str && str;
        }
      }

      // Return whether the media query matches
      return (
        core.media[query] !== false &&
        window.matchMedia(core.media[query]).matches
      );
    },

    /**
     * Registers a handler for a given query.
     * @param {string} query The query.
     * @param {function} handler The handler function.
     */
    on: function (query, handler) {
      core.events.push({
        query: query,
        handler: handler,
        state: false,
      });

      // If the query is already active, call the handler immediately
      if (core.active(query)) {
        handler();
      }
    },

    /**
     * Polls the registered events to check for state changes.
     */
    poll: function () {
      var i, e;
      for (i = 0; i < core.events.length; i++) {
        e = core.events[i];
        if (core.active(e.query)) {
          // If state changed from inactive to active, call handler
          if (!e.state) {
            e.state = true;
            e.handler();
          }
        } else {
          // If state changed from active to inactive, do nothing but update state
          if (e.state) {
            e.state = false;
          }
        }
      }
    },
  };

  // Expose internal `core` object for debugging/advanced use
  main._ = core;

  // Public methods
  main.on = function (query, handler) {
    core.on(query, handler);
  };

  main.active = function (query) {
    return core.active(query);
  };

  return main;
})();

// UMD (Universal Module Definition) wrapper
(function (root, factory) {
  if (typeof define === "function" && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof exports === "object") {
    // CommonJS
    module.exports = factory();
  } else {
    // Browser globals
    root.breakpoints = factory();
  }
})(this, function () {
  return breakpoints;
});
